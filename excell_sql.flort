Florted: 2024-09-20 09:20:55
|-- excell_sql/
|   |-- setup.py
|   |-- test/
|   |   |-- test.py
|   |   |-- __init__.py
|   |-- excelsql/
|   |   |-- __init__.py
|   |   |-- excelsql.py

Path: setup.py
File: setup.py
-------
from setuptools import setup, find_packages

# Read the contents of your README file
from pathlib import Path
this_directory = Path(__file__).parent
long_description = (this_directory / "README.md").read_text()

setup(
    name='excelsql',  # Your package name
    version='0.1.32',  # Initial version
    description='A Python driver to use SQL on Excel workbooks with CRUD, using SQLite as a middleman',
    long_description=long_description,
    long_description_content_type='text/markdown',  # This is important for PyPI
    url='https://github.com/chris17453/xlsql',  # Update with your repo URL
    author='Charles Watkins',
    author_email='chris@watkinslabs.com',
    license='BSD 3',
    packages=find_packages(where='src'),  # Specify where to find the source code
    package_dir={'': 'excelsql'},  # Tell setuptools the source directory is `src`
    install_requires=[
        'pandas',
        'openpyxl',
        'pyexcel-xls',
        'pyexcel',
        'sqlalchemy',
        'pysqlite3',
        'xlrd',
        'xlwt',
        'pyxlsb'
    ],
    python_requires='>=3.6',
    classifiers=[
        'Development Status :: 4 - Beta',
        'Intended Audience :: Developers',
        'License :: OSI Approved :: BSD License',
        'Programming Language :: Python :: 3',
        'Programming Language :: Python :: 3.6',
        'Programming Language :: Python :: 3.7',
        'Programming Language :: Python :: 3.8',
        'Programming Language :: Python :: 3.9',
        'Programming Language :: Python :: 3.10',
        'Programming Language :: Python :: 3.11',
    ],
    include_package_data=True, 
)

Path: test/test.py
File: test.py
-------
from excelsql import excelsql
import pandas as pd

xls_file = './data/file_example_XLS_5000.xls'  # Or .xlsx file
db_file = './data/excel_db.sqlite'

# Create the driver
driver = excelsql(xls_file, db_path=db_file)

# Show available worksheets
worksheets = driver.show_worksheets()

# Show columns for a specific worksheet (e.g., 'Sheet1')
if 'Sheet1' in worksheets:
    columns = driver.show_columns('Sheet1')

# Step 1: Copy data from 'Sheet1' to a new worksheet called 'CopiedSheet'
if 'Sheet1' in worksheets:
    # Fetch the data from 'Sheet1'
    df = pd.read_sql('SELECT * FROM Sheet1', driver.engine)
    
    # Create a new table for the copied data
    df.to_sql('CopiedSheet', driver.engine, if_exists='replace', index=False)
    print("Copied data to 'CopiedSheet'.")

# Step 2: Create another worksheet 'NewSheet' and insert 3 new rows
# Define new rows to insert
new_rows = [
    {'First Name': 'John', 'Last Name': 'Doe', 'Gender': 'Male', 'Country': 'USA', 'Age': 28, 'Date': '2024-09-20', 'Id': 5001},
    {'First Name': 'Jane', 'Last Name': 'Smith', 'Gender': 'Female', 'Country': 'UK', 'Age': 34, 'Date': '2024-09-21', 'Id': 5002},
    {'First Name': 'Alice', 'Last Name': 'Johnson', 'Gender': 'Female', 'Country': 'Canada', 'Age': 29, 'Date': '2024-09-22', 'Id': 5003}
]

# Convert the new rows to a DataFrame
new_rows_df = pd.DataFrame(new_rows)

# Insert the new rows into a new worksheet 'NewSheet'
new_rows_df.to_sql('NewSheet', driver.engine, if_exists='replace', index=False)
print("Inserted 3 new rows into 'NewSheet'.")

# Step 3: Save back to an Excel file in the correct format
driver.save_to_file('./data/newfile.xls')  # Or .xlsx

# Close the driver connection
driver.close()

Path: test/__init__.py
File: __init__.py
-------

Path: excelsql/__init__.py
File: __init__.py
-------
from .excelsql import excelsql

__all__ = ['excelsql']


Path: excelsql/excelsql.py
File: excelsql.py
-------
import pandas as pd
from openpyxl import load_workbook
from sqlalchemy import create_engine, MetaData, Table, Column, String, text
from sqlalchemy.orm import sessionmaker
import xlrd  # For reading .xls files
import pyexcel as p  # For writing .xls files

class excelsql:
    def __init__(self, excel_path, db_path=':memory:'):
        self.excel_path = excel_path
        self.db_path = db_path
        self.file_type = None  # To store the file type (xls or xlsx)
        
        # Detect file type (xls or xlsx)
        self._detect_file_type()

        # Create engine using pysqlite3
        self.engine = create_engine(f"sqlite+pysqlite:///{db_path}", echo=False, future=True)
        self.metadata = MetaData()
        self.Session = sessionmaker(bind=self.engine)
        self.session = self.Session()

        # Initialize the database by loading workbook sheets
        self.load_workbook_into_db()

    def _detect_file_type(self):
        """
        Detect the type of Excel file (.xls or .xlsx) based on the file extension.
        """
        if self.excel_path.endswith('.xls'):
            self.file_type = 'xls'
        elif self.excel_path.endswith('.xlsx'):
            self.file_type = 'xlsx'
        else:
            raise ValueError("Unsupported file format. Please provide an .xls or .xlsx file.")

    def load_workbook_into_db(self):
        """
        Load every sheet from the Excel workbook into SQLite tables using SQLAlchemy and pysqlite3.
        """
        if self.file_type == 'xls':
            # Use xlrd for reading .xls files
            workbook = xlrd.open_workbook(self.excel_path)
            self.sheet_names = workbook.sheet_names()
            for sheet_name in self.sheet_names:
                # Read .xls sheet into a DataFrame
                df = pd.read_excel(self.excel_path, sheet_name=sheet_name, engine='xlrd')
                # Create a table for each sheet in the SQLite database
                self.df_to_sql(df, sheet_name)
        elif self.file_type == 'xlsx':
            # Use openpyxl for reading .xlsx files
            workbook = load_workbook(self.excel_path, keep_vba=True)  # Load macros if present
            self.sheet_names = workbook.sheetnames
            for sheet_name in self.sheet_names:
                # Load each sheet as a DataFrame
                df = pd.read_excel(self.excel_path, sheet_name=sheet_name)
                # Create a table for each sheet in the SQLite database
                self.df_to_sql(df, sheet_name)

    def df_to_sql(self, df, table_name):
        """
        Convert a DataFrame to a SQLAlchemy table and store it in the SQLite database.
        """
        columns = [Column(col, String, nullable=True) for col in df.columns]
        table = Table(table_name, self.metadata, *columns)

        # Create the table if it doesn't exist
        self.metadata.create_all(self.engine)

        # Insert DataFrame rows into the table
        df.to_sql(table_name, self.engine, if_exists='replace', index=False)

    def execute_query(self, query):
        """
        Execute raw SQL queries using the pysqlite3 connection.
        """
        with self.engine.connect() as conn:
            result = conn.execute(text(query))  # Wrap the query string in text()
            return result.fetchall()

    def save_to_file(self, output_path):
        """
        Save all the worksheets (including newly created ones) back to an Excel file.
        """
        # Retrieve all table names (worksheets) from the SQLite database
        query = "SELECT name FROM sqlite_master WHERE type='table';"
        with self.engine.connect() as conn:
            tables = conn.execute(text(query)).fetchall()

        # Extract table names
        table_names = [table[0] for table in tables]

        # Check if we are saving as .xls or .xlsx
        if self.file_type == 'xls':
            self._save_as_xls(output_path, table_names)
        elif self.file_type == 'xlsx':
            self._save_as_xlsx(output_path, table_names)

    def _save_as_xlsx(self, output_path, table_names):
        """
        Save all worksheets to an .xlsx file using openpyxl.
        """
        if not output_path.endswith('.xlsx'):
            output_path += '.xlsx'  # Ensure the output file is .xlsx

        # Use openpyxl for writing Excel files
        with pd.ExcelWriter(output_path, engine='openpyxl') as writer:
            for table_name in table_names:
                # Fetch the data from the database for each table
                df = pd.read_sql(f"SELECT * FROM {table_name}", self.engine)
                df.to_excel(writer, sheet_name=table_name, index=False)

        print(f"File saved as {output_path}")

    def _save_as_xls(self, output_path, table_names):
        """
        Save all worksheets to an .xls file using pyexcel.
        """
        if not output_path.endswith('.xls'):
            output_path += '.xls'  # Ensure the output file is .xls

        data = {}
        for table_name in table_names:
            # Fetch the data from the database for each table
            df = pd.read_sql(f"SELECT * FROM {table_name}", self.engine)
            data[table_name] = df.values.tolist()  # Convert to list of lists for pyexcel

        # Save data using pyexcel
        p.save_book_as(bookdict=data, dest_file_name=output_path)
        print(f"File saved as {output_path}")


    def show_worksheets(self):
        """
        Show the names of all worksheets in the Excel workbook.
        """
        print("Available worksheets:")
        for sheet_name in self.sheet_names:
            print(f"- {sheet_name}")
        return self.sheet_names

    def show_columns(self, sheet_name):
        """
        Show the column names of a specific worksheet.
        """
        if sheet_name not in self.sheet_names:
            print(f"Worksheet '{sheet_name}' does not exist.")
            return []

        # Query to get the column names from the SQLite table
        query = text(f"PRAGMA table_info({sheet_name});")  # Use SQLAlchemy's text() for raw queries
        with self.engine.connect() as conn:
            result = conn.execute(query).fetchall()
        
        columns = [row[1] for row in result]
        print(f"Columns in '{sheet_name}': {columns}")
        return columns

    def close(self):
        """
        Close the session and the database connection.
        """
        self.session.close()
